# opencv 

## 히스토그램 

* 히스토그램은 도수 분포표를 그래프로 나타낸 것입니다. 쉽게 말해 무엇이 몇 개 있는지 개수를 세어 놓은 것을 그래프로 나타낸 것을 말합니다. 이미지의 픽셀값을 히스토그램으로 표시하는 것은 이미지를 분석하는 데 도움을 줍니다. 예를 들어 전체 이미지에서 픽셀 값이 1인 픽셀이 몇 개이고, 2인 픽셀이 몇 개이고, 255인 픽셀이 몇 개인지까지 세는 것입니다. 이렇게 함으로써 픽셀들의 색상이나 명암의 분포를 파악할 수 있습니다.

```
cv2.calcHist(img, channel, mask, histSize, ranges)
img: 이미지 영상, [img]처럼 리스트로 감싸서 전달
channel: 분석 처리할 채널, 리스트로 감싸서 전달 - 1 채널: [0], 2 채널: [0, 1], 3 채널: [0, 1, 2]
mask: 마스크에 지정한 픽셀만 히스토그램 계산, None이면 전체 영역
histSize: 계급(Bin)의 개수, 채널 개수에 맞게 리스트로 표현 - 1 채널: [256], 2 채널: [256, 256], 3 채널: [256, 256, 256]
ranges: 각 픽셀이 가질 수 있는 값의 범위, RGB인 경우 [0, 256]
```

## 정규화(Normalization)
* 특정 영역에 몰려 있는 경우 화질을 개선하기도 하고, 이미지 간의 연산 시 서로 조건이 다른 경우 같은 조건으로 만들기도 합니다. OpenCV는 cv2.normalize()라는 함수로 정규화를 제공합니다.
```
dst = cv2.normalize(src, dst, alpha, beta, type_flag)
src: 정규화 이전의 데이터
dst: 정규화 이후의 데이터
alpha: 정규화 구간 1
beta: 정규화 구간 2, 구간 정규화가 아닌 경우 사용 안 함
type_flag: 정규화 알고리즘 선택 플래그 상수
type_flag는 alpha와 beta 구간으로 정규화하는 cv2.NORM_MINMAX 
전체 합으로 나누는 cv2.NORM_L1 
단위 벡터로 정규화하는 cv2.NORM_L2 
최댓값으로 나누는 cv2.NORM_INF가 있습니다.
```

## 평탄화(Equalization)

* 앞서 설명한 정규화는 분포가 한곳에 집중되어 있는 경우에는 효과적이지만 그 집중된 영역에서 멀리 떨어진 값이 있을 경우에는 효과가 없습니다. 이런 경우 평탄화가 필요합니다. 평탄화는 각각의 값이 전체 분포에 차지하는 비중에 따라 분포를 재분배하므로 명암 대비를 개선하는 데 효과적입니다. 

* 이미지의 히스토그램이 특정 영역에 너무 집중되어 있으면 명암 대비가 낮아 좋은 이미지라고 할 수 없습니다. 전체 영역에 골고루 분포가 되어 있을 때 좋은 이미지라고 할 수 있습니다. 아래 히스토그램을 보면 좌측처럼 특정 영역에 집중되어 있는 분포를 오른쪽처럼 골고루 분포하도록 하는 작업을 히스토그램 평탄화(Histogram Equalization)라고 합니다. 

![image.png](attachment:image.png)

```
dst = cv2.equalizeHist(src, dst)
src: 대상 이미지, 8비트 1 채널
dst(optional): 결과 이미지
```

## CLAHE (Contrast Limited Adaptive Histogram Equalization)

* 지금까지 평탄화를 통해 명암 대비를 개선하여 이미지의 선명도를 높이는 작업에 대해 알아봤습니다. 하지만 평탄화를 하면 이미지의 밝은 부분이 날아가는 현상이 발생합니다. 아래의 이미지를 보겠습니다.
![image.png](attachment:image.png)
* 평탄화를 적용하니 조각상의 얼굴이 너무 밝게 바뀌어 경계선을 알아볼 수 없게 되었습니다. 평탄화를 이미지 전체에 적용하면 이런 현상이 자주 발생합니다. 이런 현상을 막기 위해 이미지를 일정한 영역(아래 코드에서 tileGridSize 파라미터)으로 나누어 평탄화를 적용합니다. 그러나 이 방식에도 문제가 있습니다. 일정한 영역 내에서 극단적으로 어둡거나 밝은 부분이 있으면 노이즈가 생겨 원하는 결과를 얻을 수 없게 됩니다. 이 문제를 피하기 위해서 어떤 영역이든 지정된 제한 값(아래 코드에서 clipLimit 파라미터)을 넘으면 그 픽셀은 다른 영역에 균일하게 배분하여 적용합니다. 이러한 평탄화 방식을 CLAHE라고 합니다.
![image-2.png](attachment:image-2.png)
```
clahe = cv2.createCLAHE(clipLimit, tileGridSize)
clipLimit: 대비(Contrast) 제한 경계 값, default=40.0
tileGridSize: 영역 크기, default=8 x 8
clahe: 생성된 CLAHE 객체
clahe.apply(src): CLAHE 적용
src: 입력 이미지
```

## 역투영(Back Projection)

* 역투영이란 관심 영역의 히스토그램과 유사한 히스토그램을 갖는 영역을 찾아내는 기법입니다. 역투영을 활용하면 이미지 내에서 특정 물체나 배경을 분리할 수 있습니다. 아래 이미지를 보겠습니다. 이미지 내에서 잔디만 분리하고 싶은 경우 잔디에 해당하는 관심 영역(ROI, region of interest)을 지정하고 역투영을 적용합니다. 그러면 잔디에 해당하는 부분은 흰색으로, 잔디가 아닌 부분은 검은색으로 서로 분리가 됩니다. 다만 이 방법은 색상을 기준으로 분리하기 때문에 잔디와 비슷한 색상을 가진 다른 물체가 있는 경우 성능이 떨어집니다.
* 역투영의 장단점
    * 역투영은 알파 채널이나 크로마 키 같은 것이 없어도 복잡한 모양의 사물을 분리할 수 있다는 장점이 있습니다. 하지만 역투영은 히스토그램을 기반으로 관심 영역의 색상과 비슷한 물체를 추출하므로, 관심 영역의 색상과 비슷한 다른 물체가 뒤섞여 있을 때는 효과가 떨어질 수 있습니다.

```
cv2.calcBackProject(img, channel, hist, ranges, scale)
img: 입력 이미지, [img]처럼 리스트로 감싸서 사용
channel: 처리할 채널, 리스트로 감싸서 사용
    1채널 [0] 2채널 [0,1] 3채널 [0,1,2]
hist: 역투영에 사용할 히스토그램
ranges: 각 픽셀이 가질 수 있는 값의 범위
scale: 결과에 적용할 배율 계수
```

## 히스토그램 비교 (이미지 유사도 비교)
* 픽셀 값의 분포가 서로 비슷하다면 유사한 이미지일 확률이 높고, 분포가 서로 다르다면 서로 다른 이미지일 확률이 높습니다. 이러한 사실을 이용하여 이미지의 유사도를 측정할 수 있습니다. 즉, 두 이미지의 히스토그램을 비교하면 되는 것입니다. OpenCV는 히스토그램을 비교하여 두 이미지가 얼마나 유사한지 판단해주는 함수를 제공합니다.
```
cv2.compareHist(hist1, hist2, method)
hist1, hist2: 비교할 두 개의 히스토그램, 크기와 차원이 같아야 함
method: 비교 알고리즘
```
* method 파라미터에는 아래와 같은 값들이 있습니다.
    * cv2.HISTCMP_CORREL: 상관관계 (1: 완전 일치, -1: 완전 불일치, 0: 무관계)
    * cv2.HISTCMP_CHISQR: 카이제곱 (0: 완전 일치, 무한대: 완전 불일치)
    * cv2.HISTCMP_INTERSECT: 교차 (1: 완전 일치, 0: 완전 불일치 - 1로 정규화한 경우)
